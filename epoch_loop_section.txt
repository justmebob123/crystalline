    printf("  Total batches:    %d\n", training->total_batches);
    printf("\n");
    
    // Training loop
    time_t start_time = time(NULL);
    
    for (int epoch = 0; epoch < config->num_epochs; epoch++) {
        training->current_epoch = epoch;
        
        printf("╔═══════════════════════════════════════════════════════════╗\n");
        printf("║ Epoch %d/%d                                               ║\n", 
               epoch + 1, config->num_epochs);
        printf("╚═══════════════════════════════════════════════════════════╝\n\n");
        
        // Use kissing spheres multi-threaded training for better performance
        float epoch_loss;
        // ALWAYS use kissing spheres architecture (no single-threaded fallback)
        printf("DEBUG: training->tokens = %p, training->num_tokens = %zu\n", 
               (void*)training->tokens, training->num_tokens);
        printf("DEBUG: batch_size = %d, sequence_length = %d\n",
               config->batch_size, config->sequence_length);
        
        // Create batch iterator for kissing spheres architecture
        printf("DEBUG: About to create batch_iterator\n");
        fflush(stdout);
        
        CLLMBatchIterator* batch_iterator = cllm_batch_iterator_create(
            training->tokens,
            training->num_tokens,
            config->batch_size,
            config->sequence_length,
            0,  // shuffle = false (maintain order)
            0   // drop_last = false (use all data)
        );
        
        printf("DEBUG: batch_iterator = %p\n", (void*)batch_iterator);
        fflush(stdout);
        
        printf("DEBUG: About to create threaded_system...\n");
        fflush(stdout);
        
        if (!batch_iterator) {
            fprintf(stderr, "\u2717 CRITICAL ERROR: Failed to create batch iterator\n");
            fprintf(stderr, "Cannot proceed without batch processing\n");
            goto cleanup;
        }
        
        // Use kissing spheres architecture (MANDATORY)
        printf("DEBUG: About to create threaded_system with %d threads\n", num_threads);
        fflush(stdout);
        
        ThreadedTrainingSystem* threaded_system = threaded_training_create(
            training,
            batch_iterator,
            num_threads
        );
        
        printf("DEBUG: threaded_system = %p\n", (void*)threaded_system);
        fflush(stdout);
        
        if (!threaded_system) {
            fprintf(stderr, "\u2717 CRITICAL ERROR: Failed to create threaded system\n");
            fprintf(stderr, "Cannot proceed without kissing spheres architecture\n");
            cllm_batch_iterator_free(batch_iterator);
            goto cleanup;
        }
        
        printf("\u2713 Using Kissing Spheres Architecture with %d worker threads\n", 
               threaded_training_get_num_workers(threaded_system));
        epoch_loss = threaded_train_epoch(threaded_system);
        threaded_training_print_stats(threaded_system);
        threaded_training_free(threaded_system);
        cllm_batch_iterator_free(batch_iterator);
        
        printf("\nEpoch %d complete: Avg Loss = %.4f, Best Loss = %.4f\n", 
               epoch + 1, epoch_loss, training->best_loss);
        
        // Generate sample
        if ((epoch + 1) % 5 == 0 || epoch == 0) {
            generate_sample(model, "the quick brown");
        }
        
        // Save checkpoint
        if ((epoch + 1) % 10 == 0 || epoch == config->num_epochs - 1) {
            save_checkpoint(model, training, checkpoint_dir);
        }
        
        // Check if max steps reached
        if (training->current_step >= config->max_steps) {
            printf("\nMax steps reached (%d)\n", config->max_steps);
            break;
